From 029ae153dca8a05fc5451ee1dee7211bf38a0bfd Mon Sep 17 00:00:00 2001
From: Jason Mobarak <jason@swiftnav.com>
Date: Wed, 18 Apr 2018 22:36:52 -0700
Subject: [PATCH] Use inotify instead of hardcoding wait time

---
 runit/runsv.c    |  32 +++++++++++----
 runit/runsvdir.c | 123 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 145 insertions(+), 10 deletions(-)

diff --git a/runit/runsv.c b/runit/runsv.c
index e0e31508a..c022b9a7a 100644
--- a/runit/runsv.c
+++ b/runit/runsv.c
@@ -343,7 +343,7 @@ static void startservice(struct svdir *s)
 		stopservice(s); /* should never happen */
 	while ((p = vfork()) == -1) {
 		warn_cannot("vfork, sleeping");
-		sleep(5);
+		usleep(100e3); // sleep(5);
 	}
 	if (p == 0) {
 		/* child */
@@ -455,6 +455,20 @@ static int ctrl(struct svdir *s, char c)
 	return 1;
 }
 
+static int tscmp(const struct timespec *t1, const struct timespec *t2)
+{
+  if (t1->tv_sec < t2->tv_sec)
+    return (-1);
+  else if (t1->tv_sec > t2->tv_sec)
+    return (1);
+  else if (t1->tv_nsec < t2->tv_nsec)
+    return (-1);
+  else if (t1->tv_nsec > t2->tv_nsec)
+    return (1);
+  else
+    return (0);
+}
+
 int runsv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int runsv_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -578,7 +592,7 @@ int runsv_main(int argc UNUSED_PARAM, char **argv)
 	}
 	for (;;) {
 		struct pollfd x[3];
-		unsigned deadline;
+    struct timespec deadline;
 		char ch;
 
 		if (haslog)
@@ -628,11 +642,12 @@ int runsv_main(int argc UNUSED_PARAM, char **argv)
 					}
 				}
 				svd[0].state = S_DOWN;
-				deadline = svd[0].start.tv_sec + 1;
+				deadline.tv_sec = svd[0].start.tv_sec;
+				deadline.tv_nsec = svd[0].start.tv_nsec + 100e6;
 				gettimeofday_ns(&svd[0].start);
 				update_status(&svd[0]);
-				if (LESS(svd[0].start.tv_sec, deadline))
-					sleep(1);
+				if (tscmp(&svd[0].start, &deadline) < 0)
+					usleep(100e3); // sleep(1);
 			}
 			if (haslog) {
 				if (child == svd[1].pid) {
@@ -641,11 +656,12 @@ int runsv_main(int argc UNUSED_PARAM, char **argv)
 					pidchanged = 1;
 					svd[1].state = S_DOWN;
 					svd[1].ctrl &= ~C_TERM;
-					deadline = svd[1].start.tv_sec + 1;
+					deadline.tv_sec = svd[1].start.tv_sec;
+					deadline.tv_nsec = svd[1].start.tv_nsec + 100e6;
 					gettimeofday_ns(&svd[1].start);
 					update_status(&svd[1]);
-					if (LESS(svd[1].start.tv_sec, deadline))
-						sleep(1);
+					if (tscmp(&svd[1].start, &deadline) < 0)
+						usleep(100e3); // sleep(1);
 				}
 			}
 		} /* for (;;) */
diff --git a/runit/runsvdir.c b/runit/runsvdir.c
index 84916e929..7c946a2d2 100644
--- a/runit/runsvdir.c
+++ b/runit/runsvdir.c
@@ -55,6 +55,8 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 //usage:     "\n	-P		Put each runsv in a new session"
 //usage:     "\n	-s SCRIPT	Run SCRIPT <signo> after signal is processed"
 
+#include <assert.h>
+#include <sys/inotify.h>
 #include <sys/file.h>
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -232,6 +234,122 @@ static NOINLINE int do_rescan(void)
 	return need_rescan;
 }
 
+#define BUF_LEN (10 * (sizeof(struct inotify_event) + NAME_MAX + 1))
+//#define DEBUG_RUNSVDIR
+
+static void wait_sv_create(char* the_dir, int deadline)
+{
+	bool need_sleep_fallback = true;
+
+	int inotify_fd = -1, watch_fd = -1, rv;
+	ssize_t buflen;
+
+	char inotify_buf[BUF_LEN] __attribute__ ((aligned(__alignof__(struct inotify_event))));
+
+	struct pollfd pfds[1];
+	inotify_fd = inotify_init1(IN_NONBLOCK);
+
+	if (inotify_fd < 0) {
+		//bb_perror_msg("wait_sv_create: inotify init failed");
+		goto cleanup;
+	}
+
+#ifdef DEBUG_RUNSVDIR
+	fprintf(stderr, "wait_sv_create: the_dir: %s\n", the_dir);
+#endif
+	watch_fd = inotify_add_watch(inotify_fd, the_dir, IN_CREATE|IN_DELETE|IN_MOVE);
+
+	if (watch_fd < 0) {
+#ifdef DEBUG_RUNSVDIR
+		bb_perror_msg("wait_sv_create: inotify add failed");
+#endif
+		goto cleanup;
+	}
+
+	pfds[0].fd = inotify_fd;
+	pfds[0].events = POLLIN|POLLERR;
+
+	rv = poll(pfds, 1, deadline*1000);
+	if (rv == 0) {
+#ifdef DEBUG_RUNSVDIR
+		fprintf(stderr, "wait_sv_create: timeout\n");
+#endif
+		need_sleep_fallback = false;
+		goto cleanup; // timeout
+	}
+
+	if (pfds[0].revents & POLLERR) {
+		bb_error_msg("wait_sv_create: inotify fd error state signaled");
+		goto cleanup;
+	}
+
+	if (rv < 0) {
+		bb_perror_msg("wait_sv_create: poll command failed");
+		goto cleanup;
+	}
+
+	buflen = read(inotify_fd, inotify_buf, BUF_LEN);
+	need_sleep_fallback = false;
+
+	if (buflen < 0) {
+		bb_perror_msg("wait_sv_create: inotify read failed");
+		goto cleanup;
+	}
+
+	if (buflen == 0) {
+		bb_error_msg("wait_sv_create: inotify read eof");
+		goto cleanup;
+	}
+
+	for (char* p = inotify_buf; p < inotify_buf + buflen; ) {
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wcast-align"
+		struct inotify_event *event = (struct inotify_event *) p;
+#pragma GCC diagnostic pop
+
+		if (event->mask & IN_CREATE) {
+#ifdef DEBUG_RUNSVDIR
+			fprintf(stderr, "wait_sv_create: got notification that '%s' was created\n", event->name);
+#endif
+		} else if (event->mask & IN_DELETE) {
+#ifdef DEBUG_RUNSVDIR
+			fprintf(stderr, "wait_sv_create: got notification that '%s' was deleted\n", event->name);
+#endif
+		} else if (event->mask & IN_MOVE) {
+#ifdef DEBUG_RUNSVDIR
+			fprintf(stderr, "wait_sv_create: got notification that '%s' was moved\n", event->name);
+#endif
+		} else {
+			bb_error_msg("wait_sv_create: unhandled inotify event");
+		}
+
+		p += sizeof(struct inotify_event) + event->len;
+	}
+
+cleanup:
+	if (inotify_fd >= 0 && watch_fd >= 0) {
+		rv = inotify_rm_watch(inotify_fd, watch_fd);
+		if (rv < 0)
+			bb_perror_msg("wait_sv_create: inotify_rm_watch failed");
+	}
+
+	if (inotify_fd >= 0) {
+		rv = close(inotify_fd);
+		if (rv < 0)
+			bb_perror_msg("wait_sv_create: closing inotify fd failed");
+	}
+
+	if (need_sleep_fallback) {
+#ifdef DEBUG_RUNSVDIR
+		bb_error_msg("wait_sv_create: using sleep fallback");
+#endif
+		usleep(100000);
+	}
+
+	return;
+}
+
 int runsvdir_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int runsvdir_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -348,7 +466,8 @@ int runsvdir_main(int argc UNUSED_PARAM, char **argv)
 						need_rescan = do_rescan();
 						while (fchdir(curdir) == -1) {
 							warn2_cannot("change directory, pausing", "");
-							sleep(5);
+							usleep(100000);
+							//sleep(5);
 						}
 					} else {
 						warn2_cannot("change directory to ", svdir);
@@ -375,7 +494,7 @@ int runsvdir_main(int argc UNUSED_PARAM, char **argv)
 				poll(pfd, 1, deadline*1000);
 			else
 #endif
-				sleep(deadline);
+				wait_sv_create(svdir, deadline);
 		}
 
 #if ENABLE_FEATURE_RUNSVDIR_LOG
-- 
2.15.0

